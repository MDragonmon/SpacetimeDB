extern crate core;
extern crate proc_macro;

use convert_case::{Case, Casing};
use proc_macro::TokenStream;
use quote::{quote, ToTokens};
use std::fmt::Write;
use syn::{FnArg, ItemFn, ItemStruct};
use crate::rust_to_spacetimedb_ident;

/// This returns a function which will return the schema (TypeDef) for a struct. The signature
/// for this function is as follows:
/// fn __get_struct_schema__<struct_type_ident>() -> spacetimedb_bindings::TypeDef {
///   ...
/// }
pub(crate) fn csharp_get_type_def_for_struct(original_struct: ItemStruct) -> String {
    let mut col_num: u8 = 0;
    let mut element_defs : String = String::new();

    for field in &original_struct.fields {
        let field_type = field.ty.clone().to_token_stream().to_string();

        match rust_to_spacetimedb_ident(field.ty.clone().to_token_stream().to_string().as_str()) {
            None => {
                let csharp_type = field_type.to_case(Case::Pascal);
                write!(element_defs, "\t\t\t\tnew SpacetimeDB.ElementDef({}, SpacetimeDB.{}.GetTypeDef()),\n", col_num, csharp_type).unwrap();
            }
            Some(spacetimedb_type) => {
                match spacetimedb_type.to_string().as_str() {
                    "Vec" => {
                        // This really sucks here, we have to process the vec generic type and see how that needs to be broken down.
                        panic!("Please no vecs in tuple defs for now!");
                        // match get_type_from_vec(field.ty.clone()) {
                        //     Some(t) => {
                        //         write!(element_defs, "\t\telement_type = SpacetimeDB.TypeDef.GetVec(SpacetimeDB.TypeDef.{}),\n", ).unwrap();
                        //     }, None => {
                        //         panic!("Internal error: This type is not a vec: {}", spacetimedb_type.to_string())
                        //     }
                        // }

                    }
                    _ => {
                        write!(element_defs, "\t\t\t\tnew SpacetimeDB.ElementDef({}, SpacetimeDB.TypeDef.BuiltInType(SpacetimeDB.TypeDef.Def.{})),\n", col_num, spacetimedb_type).unwrap();
                    }
                }
            }
        }

        col_num = col_num + 1;
    }

    let mut result : String = String::new();

    write!(result, "\t\tpublic static TypeDef GetTypeDef()\n").unwrap();
    write!(result, "\t\t{{\n").unwrap();
    write!(result, "\t\t\treturn TypeDef.Tuple(new ElementDef[]\n").unwrap();
    write!(result, "\t\t\t{{\n").unwrap();
    write!(result, "{}", element_defs).unwrap();
    write!(result, "\t\t\t}});\n").unwrap();
    write!(result, "\t\t}}\n").unwrap();
    return result;
}

/// Creates a C# reducer function for the given rust reducer. All reducers are exported as static
/// functions in a class called Reducer.
pub(crate) fn spacetimedb_csharp_reducer(original_function: ItemFn) -> TokenStream {
    let func_name = &original_function.sig.ident;
    let reducer_pascal_name = func_name.to_token_stream().to_string().to_case(Case::Pascal);
    let use_namespace = true;
    let namespace = "SpacetimeDB";
    let namespace_tab = if use_namespace { "\t" } else { "" };
    let func_name_pascal_case = func_name.to_string().to_case(Case::Pascal);

    let mut output_contents: String = String::new();
    let mut func_arguments: String = String::new();
    let mut arg_names: String = String::new();

    write!(output_contents, "// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n").unwrap();
    write!(output_contents, "// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.\n\n").unwrap();

    if use_namespace {
        write!(output_contents, "namespace {} \n{{\n", namespace).unwrap();
    }

    write!(output_contents, "{}public static partial class Reducer \n{}{{\n", namespace_tab, namespace_tab).unwrap();

    let mut arg_num: usize = 0;
    let mut inserted_args: usize = 0;
    for function_argument in original_function.sig.inputs.iter() {
        match function_argument {
            FnArg::Typed(typed) => {
                let arg_type = &typed.ty;
                let arg_type = arg_type.to_token_stream().to_string();
                let arg_name = &typed.pat.to_token_stream().to_string().to_case(Case::Camel);

                // Skip any arguments that are supplied by spacetimedb
                if arg_num == 0 && typed.ty.to_token_stream().to_string() == "Hash"
                    || arg_num == 1 && typed.ty.to_token_stream().to_string() == "u64" {
                    arg_num = arg_num + 1;
                    continue;
                }

                if inserted_args > 0 {
                    write!(func_arguments, ", ").unwrap();
                    write!(arg_names, ", ").unwrap();
                }

                match rust_type_to_csharp_raw_type(arg_type.as_str()) {
                    Some(csharp_type) => {
                        write!(func_arguments, "{} {}", csharp_type, arg_name).unwrap();
                    } None => {
                        match arg_type.as_str() {
                            "Hash" => {
                                write!(func_arguments, "SpacetimeDB.Hash {}", arg_name).unwrap();
                            }, _ => {
                                // This is hopefully a type understood by C# (Vec will cause issues here)
                                write!(func_arguments, "{} {}", arg_type.as_str(), arg_name).unwrap();
                            }
                        }
                    }
                }

                write!(arg_names, "{}", arg_name.clone()).unwrap();
                inserted_args += 1;
            }
            _ => {}
        }

        arg_num = arg_num + 1;
    }

    write!(output_contents, "{}\tpublic static void {}({})\n", namespace_tab, func_name_pascal_case, func_arguments).unwrap();
    write!(output_contents, "{}\t{{\n", namespace_tab).unwrap();

    //            StdbNetworkManager.instance.InternalCallReducer(new StdbNetworkManager.Message
    // 			{
    // 				fn = "create_new_player",
    // 				args = new object[] { playerId, position },
    // 			});

    // Tell the network manager to send this message
    // UPGRADE FOR LATER
    // write!(output_contents, "{}\t\tStdbNetworkManager.instance.InternalCallReducer(new Websocket.FunctionCall\n", namespace_tab).unwrap();
    // write!(output_contents, "{}\t\t{{\n", namespace_tab).unwrap();
    // write!(output_contents, "{}\t\t\tReducer = \"{}\",\n", namespace_tab, func_name).unwrap();
    // write!(output_contents, "{}\t\t\tArgBytes = Google.Protobuf.ByteString.CopyFrom(Newtonsoft.Json.JsonConvert.SerializeObject(new object[] {{ {} }}), System.Text.Encoding.UTF8),\n", namespace_tab, arg_names).unwrap();
    // write!(output_contents, "{}\t\t}});\n", namespace_tab).unwrap();

    // TEMPORARY OLD FUNCTIONALITY
    write!(output_contents, "{}\t\tStdbNetworkManager.instance.InternalCallReducer(new StdbNetworkManager.Message\n", namespace_tab).unwrap();
    write!(output_contents, "{}\t\t{{\n", namespace_tab).unwrap();
    write!(output_contents, "{}\t\t\tfn = \"{}\",\n", namespace_tab, func_name).unwrap();
    write!(output_contents, "{}\t\t\targs = new object[] {{ {} }},\n", namespace_tab, arg_names).unwrap();
    write!(output_contents, "{}\t\t}});\n", namespace_tab).unwrap();

    // Closing brace for reducer
    write!(output_contents, "{}\t}}\n", namespace_tab).unwrap();
    // Closing brace for class
    write!(output_contents, "{}}}\n", namespace_tab).unwrap();

    if use_namespace {
        write!(output_contents, "}}\n").unwrap();
    }

    // Write the csharp output
    if !std::path::Path::new("cs-src").is_dir() {
        std::fs::create_dir(std::path::Path::new("cs-src")).unwrap();
    }
    let path = format!("cs-src/{}Reducer.cs", reducer_pascal_name);
    std::fs::write(path, output_contents).unwrap();

    proc_macro::TokenStream::from(quote! {
        // Reducer C# generation
    })
}

/// Creates a C# class from an ItemStruct, with an optional table number (only for tables).
pub(crate) fn spacetimedb_csharp_tuple(original_struct: ItemStruct, table_num: Option<u32>) -> proc_macro2::TokenStream {
    let namespace = "SpacetimeDB";

    let original_struct_ident = &original_struct.clone().ident;
    let struct_name_pascal_case = original_struct_ident.to_string().to_case(Case::Pascal);

    let mut col_num: usize = 0;
    let mut output_contents: String = String::new();

    write!(
        output_contents, "{}{}",
        "// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n",
        "// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.\n\n"
    ).unwrap();
    write!(output_contents, "namespace {}\n{{\n", namespace).unwrap();

    write!(output_contents, "\tpublic partial class {}\n", struct_name_pascal_case).unwrap();
    write!(output_contents, "\t{{\n").unwrap();

    for field in &original_struct.fields {
        let col_name = &field.ident.clone().unwrap();
        write!(output_contents, "\t\t[Newtonsoft.Json.JsonProperty(\"{}\")]\n", col_name).unwrap();

        match rust_type_to_csharp_raw_type(field.ty.to_token_stream().to_string().as_str()) {
            Some(raw_type) => {
                write!(
                    output_contents,
                    "\t\tpublic {} {};\n",
                    raw_type,
                    col_name.to_token_stream().to_string().to_case(Case::Camel),
                ).unwrap();
            } None => {
                match field.ty.to_token_stream().to_string().as_str() {
                    "Hash" => {
                        write!(
                            output_contents,
                            "\t\tpublic SpacetimeDB.Hash {};\n",
                            col_name.to_token_stream().to_string().to_case(Case::Camel),
                        ).unwrap();
                    } _ => {
                        write!(
                            output_contents,
                            "\t\tpublic {} {};\n",
                            field.ty.to_token_stream().to_string().as_str(),
                            col_name.to_token_stream().to_string().to_case(Case::Camel),
                        ).unwrap();
                    }
                }
            }
        }

        col_num = col_num + 1;
    }

    // Insert the GetTypeDef func
    write!(output_contents, "{}", csharp_get_type_def_for_struct(original_struct.clone())).unwrap();

    // Insert the tuple to struct function
    write!(output_contents, "{}", autogen_csharp_tuple_to_struct(original_struct.clone())).unwrap();

    // If this is a table, we want to include functions for accessing the table data
    if let Some(table_num) = table_num {
        // Insert the funcs for accessing this struct
        match autogen_csharp_access_funcs_for_struct(original_struct.clone(), table_num) {
            Ok(func) => {
                write!(output_contents, "{}", func).unwrap();
            }, Err(err) => {
                return quote! {
                    compile_error!("{}", #err);
                };
            }
        }
    }

    // class close brace
    write!(output_contents, "\t}}\n").unwrap();
    // namespace close brace
    write!(output_contents, "}}\n").unwrap();

    // Write the cs output
    if !std::path::Path::new("cs-src").is_dir() {
        std::fs::create_dir(std::path::Path::new("cs-src")).unwrap();
    }
    let path = format!("cs-src/{}.cs", struct_name_pascal_case);
    std::fs::write(path, output_contents).unwrap();

    // Output all macro data
    quote! {
        // C# generated
    }
}

/// Creates a C# function that takes in a TypeValue and converts it to the fully qualified type.
fn autogen_csharp_tuple_to_struct(original_struct: ItemStruct) -> String {
    let original_struct_ident = &original_struct.clone().ident;
    let mut col_num: usize = 0;

    let csharp_struct_type = original_struct_ident.to_string().to_case(Case::Pascal);

    let mut output_contents: String = String::new();
    write!(output_contents, "\t\tpublic static {} From(TypeValue value)\n", csharp_struct_type).unwrap();
    write!(output_contents, "\t\t{{\n").unwrap();
    write!(output_contents, "\t\t\tvar tupleValue = value.GetValue(TypeDef.Def.Tuple) as TypeValue[];\n").unwrap();
    write!(output_contents, "\t\t\tif (tupleValue == null)\n").unwrap();
    write!(output_contents, "\t\t\t{{\n").unwrap();
    write!(output_contents, "\t\t\t\tthrow new System.InvalidOperationException(\"Invalid value (must be Tuple): {{value.GetType()}}\");\n").unwrap();
    write!(output_contents, "\t\t\t}}\n").unwrap();
    write!(output_contents, "\t\t\treturn new {}\n", csharp_struct_type).unwrap();
    write!(output_contents, "\t\t\t{{\n").unwrap();

    for field in &original_struct.fields {
        let field_type = field.ty.clone().to_token_stream().to_string();
        let field_type = field_type.as_str();
        let field_ident = field.clone().ident.unwrap();
        let csharp_field_type = field_type.to_case(Case::Pascal);
        let csharp_field_name = field_ident.to_string().to_case(Case::Camel);

        match rust_type_to_csharp_raw_type(field_type) {
            Some(csharp_type) => {
                write!(output_contents, "\t\t\t\t{} = ({})tupleValue[{}].GetValue(TypeDef.Def.{}),\n",
                       csharp_field_name, csharp_type, col_num, field_type.to_case(Case::Pascal)).unwrap();
            }, None => {
                match field_type {
                    "Hash" => {
                        write!(output_contents, "\t\t\t\t{} = SpacetimeDB.Hash.From(tupleValue[{}].GetValue(TypeDef.Def.Bytes) as byte[]),\n",
                               csharp_field_name, col_num).unwrap();
                    }, _ => {
                        // This is hopefully another stdb type
                        write!(output_contents, "\t\t\t\t{} = {}.From(tupleValue[{}]),\n", csharp_field_name, csharp_field_type, col_num).unwrap();
                    }
                }


            }
        }

        col_num = col_num + 1;
    }

    // End Struct
    write!(output_contents, "\t\t\t}};\n").unwrap();
    // End Func
    write!(output_contents, "\t\t}}\n").unwrap();

    return output_contents;
}

fn autogen_csharp_access_funcs_for_struct(original_struct: ItemStruct, table_num: u32) -> Result<String, &'static str> {
    let original_struct_ident = &original_struct.clone().ident;
    let mut col_num: usize = 0;

    let csharp_struct_type = original_struct_ident.to_string().to_case(Case::Pascal);

    let mut output_contents: String = String::new();
    let mut primary_key_set = false;

    for field in &original_struct.fields {
        let field_type = field.ty.clone().to_token_stream().to_string();
        let field_type = field_type.as_str();
        let field_ident = field.clone().ident.unwrap();
        let csharp_field_type: String;
        let csharp_field_name_pascal = field_ident.to_token_stream().to_string().to_case(Case::Pascal);
        match rust_type_to_csharp_raw_type(field_type) {
            Some(csharp_type) => {
                csharp_field_type = csharp_type.to_string();
            }, None => {
                csharp_field_type = field_type.to_string();
            }
        }


        let mut is_primary = false;
        for attr in &field.attrs {
            if attr.path.to_token_stream().to_string().eq("primary_key") {
                if primary_key_set {
                    return Err("Only one primary key is allowed per table (for now)");
                }

                is_primary = true;
                primary_key_set = true;
            }
        }

        if is_primary {
            write!(output_contents, "\t\tpublic static {} FilterBy{}({} value)\n", csharp_struct_type, csharp_field_name_pascal, csharp_field_type).unwrap();
        } else {
            write!(output_contents, "\t\tpublic static System.Collections.Generic.IEnumerable<{}> FilterBy{}({} value)\n", csharp_struct_type, csharp_field_name_pascal, csharp_field_type).unwrap();
        }

        write!(output_contents, "\t\t{{\n").unwrap();
        write!(output_contents, "\t\t\tvar typeDef = GetTypeDef();\n").unwrap();
        write!(output_contents, "\t\t\tforeach(var entry in StdbNetworkManager.clientDB.GetEntries({}))\n", table_num).unwrap();
        write!(output_contents, "\t\t\t{{\n").unwrap();
        write!(output_contents, "\t\t\t\tvar tupleArr = entry.GetValue(TypeDef.Def.Tuple) as TypeValue[];\n").unwrap();
        write!(output_contents, "\t\t\t\tif (tupleArr == null)\n").unwrap();
        write!(output_contents, "\t\t\t\t{{\n").unwrap();
        write!(output_contents, "\t\t\t\t\tcontinue;\n").unwrap();
        write!(output_contents, "\t\t\t\t}}\n").unwrap();

        match rust_type_to_csharp_raw_type(field_type) {
            Some(csharp_type) => {
                write!(output_contents, "\t\t\t\tvar compareValue = ({})tupleArr[{}].GetValue(TypeDef.Def.{});\n",
                       csharp_type, col_num, field_type.to_case(Case::Pascal)).unwrap();
                write!(output_contents, "\t\t\t\tif (compareValue == value)\n",).unwrap();
            }, None => {
                match field_type {
                    "Hash" => {
                        write!(output_contents, "\t\t\t\tvar compareValue = SpacetimeDB.Hash.From(tupleArr[{}].GetValue(TypeDef.Def.Bytes) as byte[]);\n", col_num).unwrap();
                        write!(output_contents, "\t\t\t\tif (compareValue.Equals(value))\n",).unwrap();
                    }, _ => {
                        // This is hopefully another stdb type
                        write!(output_contents, "\t\t\t\tvar compareValue = {}.From(tupleArr[{}]);\n", csharp_field_type, col_num).unwrap();
                        write!(output_contents, "\t\t\t\tif (compareValue.Equals(value))\n",).unwrap();
                    }
                }
            }
        }

        write!(output_contents, "\t\t\t\t{{\n",).unwrap();
        write!(output_contents, "\t\t\t\t\tvar tuple = TypeValue.GetTuple(typeDef, tupleArr);\n").unwrap();
        if is_primary {
            write!(output_contents, "\t\t\t\t\treturn From(tuple);\n").unwrap();
        } else {
            write!(output_contents, "\t\t\t\t\tyield return From(tuple);\n").unwrap();
        }
        // End foreach
        write!(output_contents, "\t\t\t\t}}\n",).unwrap();

        // End Struct
        write!(output_contents, "\t\t\t}}\n").unwrap();

        if is_primary {
            write!(output_contents, "\t\t\treturn null;\n").unwrap();
        }

        // End Func
        write!(output_contents, "\t\t}}\n").unwrap();
        col_num = col_num + 1;
    }

    return Ok(output_contents);
}

pub(crate) fn rust_type_to_csharp_raw_type(type_string: &str) -> Option<&str> {
    return match type_string {
        "bool" => Some("bool"),
        "i8" => Some("sbyte"),
        "u8" => Some("byte"),
        "i16" => Some("short"),
        "u16" => Some("ushort"),
        "i32" => Some("int"),
        "u32" => Some("uint"),
        "i64" => Some("long"),
        "u64" => Some("ulong"),
        // "i128" => "int128", Not a supported type in csharp
        // "u128" => "uint128", Not a supported type in csharp
        "String" => Some("string"),
        "&str" => Some("string"),
        "f32" => Some("float"),
        "f64" => Some("double"),
        _ => {
            return None;
        }
    };
}

