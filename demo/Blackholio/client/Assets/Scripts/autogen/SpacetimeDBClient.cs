// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

// <auto-generated />

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB.Types
{
    public sealed partial class RemoteReducers : RemoteBase<DbConnection>
    {
        internal RemoteReducers(DbConnection conn, SetReducerFlags SetReducerFlags) : base(conn) { this.SetCallReducerFlags = SetReducerFlags; }
        internal readonly SetReducerFlags SetCallReducerFlags;
    }

    public sealed partial class SetReducerFlags
    {
        internal SetReducerFlags() { }
    }

    public sealed record EventContext : DbContext<RemoteTables>, IEventContext
    {
        public readonly RemoteReducers Reducers;
        public readonly SetReducerFlags SetReducerFlags;
        public readonly Event<Reducer> Event;

        internal EventContext(DbConnection conn, Event<Reducer> reducerEvent) : base(conn.Db)
        {
            Reducers = conn.Reducers;
            SetReducerFlags = conn.SetReducerFlags;
            Event = reducerEvent;
        }
    }

    public abstract partial class Reducer
    {
        private Reducer() { }

        public sealed class StdbNone : Reducer { }
    }

    public sealed class DbConnection : DbConnectionBase<DbConnection, Reducer>
    {
        public readonly RemoteTables Db = new();
        public readonly RemoteReducers Reducers;
        public readonly SetReducerFlags SetReducerFlags;

        public DbConnection()
        {
            SetReducerFlags = new();
            Reducers = new(this, this.SetReducerFlags);

            clientDB.AddTable<Circle>("circle", Db.Circle);
            clientDB.AddTable<CircleDecayTimer>("circle_decay_timer", Db.CircleDecayTimer);
            clientDB.AddTable<CircleRecombineTimer>("circle_recombine_timer", Db.CircleRecombineTimer);
            clientDB.AddTable<Config>("config", Db.Config);
            clientDB.AddTable<ConsumeEntityTimer>("consume_entity_timer", Db.ConsumeEntityTimer);
            clientDB.AddTable<Entity>("entity", Db.Entity);
            clientDB.AddTable<Food>("food", Db.Food);
            clientDB.AddTable<LoggedOutPlayer>("logged_out_player", Db.LoggedOutPlayer);
            clientDB.AddTable<MoveAllPlayersTimer>("move_all_players_timer", Db.MoveAllPlayersTimer);
            clientDB.AddTable<Player>("player", Db.Player);
            clientDB.AddTable<SpawnFoodTimer>("spawn_food_timer", Db.SpawnFoodTimer);
        }

        protected override Reducer ToReducer(TransactionUpdate update)
        {
            var encodedArgs = update.ReducerCall.Args;
            return update.ReducerCall.ReducerName switch
            {
                "circle_decay" => BSATNHelpers.Decode<Reducer.CircleDecay>(encodedArgs),
                "circle_recombine" => BSATNHelpers.Decode<Reducer.CircleRecombine>(encodedArgs),
                "connect" => BSATNHelpers.Decode<Reducer.Connect>(encodedArgs),
                "consume_entity" => BSATNHelpers.Decode<Reducer.ConsumeEntity>(encodedArgs),
                "disconnect" => BSATNHelpers.Decode<Reducer.Disconnect>(encodedArgs),
                "enter_game" => BSATNHelpers.Decode<Reducer.EnterGame>(encodedArgs),
                "move_all_players" => BSATNHelpers.Decode<Reducer.MoveAllPlayers>(encodedArgs),
                "player_split" => BSATNHelpers.Decode<Reducer.PlayerSplit>(encodedArgs),
                "respawn" => BSATNHelpers.Decode<Reducer.Respawn>(encodedArgs),
                "spawn_food" => BSATNHelpers.Decode<Reducer.SpawnFood>(encodedArgs),
                "suicide" => BSATNHelpers.Decode<Reducer.Suicide>(encodedArgs),
                "update_player_input" => BSATNHelpers.Decode<Reducer.UpdatePlayerInput>(encodedArgs),
                "<none>" or "" => new Reducer.StdbNone(),
                var reducer => throw new ArgumentOutOfRangeException("Reducer", $"Unknown reducer {reducer}")
            };
        }

        protected override IEventContext ToEventContext(Event<Reducer> reducerEvent) =>
        new EventContext(this, reducerEvent);

        protected override bool Dispatch(IEventContext context, Reducer reducer)
        {
            var eventContext = (EventContext)context;
            return reducer switch
            {
                Reducer.CircleDecay args => Reducers.InvokeCircleDecay(eventContext, args),
                Reducer.CircleRecombine args => Reducers.InvokeCircleRecombine(eventContext, args),
                Reducer.Connect args => Reducers.InvokeConnect(eventContext, args),
                Reducer.ConsumeEntity args => Reducers.InvokeConsumeEntity(eventContext, args),
                Reducer.Disconnect args => Reducers.InvokeDisconnect(eventContext, args),
                Reducer.EnterGame args => Reducers.InvokeEnterGame(eventContext, args),
                Reducer.MoveAllPlayers args => Reducers.InvokeMoveAllPlayers(eventContext, args),
                Reducer.PlayerSplit args => Reducers.InvokePlayerSplit(eventContext, args),
                Reducer.Respawn args => Reducers.InvokeRespawn(eventContext, args),
                Reducer.SpawnFood args => Reducers.InvokeSpawnFood(eventContext, args),
                Reducer.Suicide args => Reducers.InvokeSuicide(eventContext, args),
                Reducer.UpdatePlayerInput args => Reducers.InvokeUpdatePlayerInput(eventContext, args),
                Reducer.StdbNone => true,
                _ => throw new ArgumentOutOfRangeException("Reducer", $"Unknown reducer {reducer}")
            };
        }

        public SubscriptionBuilder<EventContext> SubscriptionBuilder() => new(this);
    }
}
